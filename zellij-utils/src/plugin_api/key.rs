// This file contains conversion code between `Key` and `ProtobufKey`
// `Key` - this is the struct used by both Zellij and Rust plugins
// `ProtobufKey` - this is the struct generated by the `.proto` file and used for serialization
// across the wasm boundary
//
// SDK authors in other languages should generate their own equivalent structures based on the
// `.proto` specification, and then decode the protobuf over the wire into them

pub use super::generated_api::api::key::{Key as ProtobufKey, key::{NamedKey, MainKey, OptionalModifier, KeyModifier}};
use crate::data::{CharOrArrow, Direction, Key};

use std::convert::TryFrom;

impl TryFrom<ProtobufKey> for Key {
    type Error = &'static str;
    fn try_from(protobuf_key: ProtobufKey) -> Result<Self, &'static str> {
        let key_modifier = parse_optional_modifier(&protobuf_key);
        match key_modifier {
            Some(KeyModifier::Ctrl) => {
                let character = char_from_main_key(protobuf_key.main_key)?;
                Ok(Key::Ctrl(character))

            },
            Some(KeyModifier::Alt) => {
                let char_or_arrow = CharOrArrow::from_main_key(protobuf_key.main_key)?;
                Ok(Key::Alt(char_or_arrow))
            },
            None => {
                match protobuf_key.main_key.as_ref().ok_or("invalid key")? {
                    MainKey::Char(_key_index) => {
                        let character = char_from_main_key(protobuf_key.main_key)?;
                        Ok(Key::Char(character))
                    },
                    MainKey::Key(key_index) => {
                        let key = NamedKey::from_i32(*key_index).ok_or("invalid_key")?;
                        Ok(named_key_to_key(key))
                    }
                }
            }
        }
    }
}

impl TryFrom<Key> for ProtobufKey {
    type Error = &'static str;
    fn try_from(key: Key) -> Result<Self, &'static str> {
        match key {
            Key::PageDown => {
                Ok(ProtobufKey {
                    optional_modifier: None,
                    main_key: Some(MainKey::Key(NamedKey::PageDown as i32)),
                })
            },
            Key::PageUp => {
                Ok(ProtobufKey {
                    optional_modifier: None,
                    main_key: Some(MainKey::Key(NamedKey::PageUp as i32)),
                })
            },
            Key::Left => {
                Ok(ProtobufKey {
                    optional_modifier: None,
                    main_key: Some(MainKey::Key(NamedKey::LeftArrow as i32)),
                })
            }
            Key::Down => {
                Ok(ProtobufKey {
                    optional_modifier: None,
                    main_key: Some(MainKey::Key(NamedKey::DownArrow as i32)),
                })
            }
            Key::Up => {
                Ok(ProtobufKey {
                    optional_modifier: None,
                    main_key: Some(MainKey::Key(NamedKey::UpArrow as i32)),
                })
            }
            Key::Right => {
                Ok(ProtobufKey {
                    optional_modifier: None,
                    main_key: Some(MainKey::Key(NamedKey::RightArrow as i32)),
                })
            }
            Key::Home => {
                Ok(ProtobufKey {
                    optional_modifier: None,
                    main_key: Some(MainKey::Key(NamedKey::Home as i32)),
                })
            }
            Key::End => {
                Ok(ProtobufKey {
                    optional_modifier: None,
                    main_key: Some(MainKey::Key(NamedKey::End as i32)),
                })
            }
            Key::Backspace => {
                Ok(ProtobufKey {
                    optional_modifier: None,
                    main_key: Some(MainKey::Key(NamedKey::Backspace as i32)),
                })
            }
            Key::Delete => {
                Ok(ProtobufKey {
                    optional_modifier: None,
                    main_key: Some(MainKey::Key(NamedKey::Delete as i32)),
                })
            }
            Key::Insert => {
                Ok(ProtobufKey {
                    optional_modifier: None,
                    main_key: Some(MainKey::Key(NamedKey::Insert as i32)),
                })
            }
            Key::F(index) => {
                let main_key = match index {
                    1 => Some(MainKey::Key(NamedKey::F1 as i32)),
                    2 => Some(MainKey::Key(NamedKey::F2 as i32)),
                    3 => Some(MainKey::Key(NamedKey::F3 as i32)),
                    4 => Some(MainKey::Key(NamedKey::F4 as i32)),
                    5 => Some(MainKey::Key(NamedKey::F5 as i32)),
                    6 => Some(MainKey::Key(NamedKey::F6 as i32)),
                    7 => Some(MainKey::Key(NamedKey::F7 as i32)),
                    8 => Some(MainKey::Key(NamedKey::F8 as i32)),
                    9 => Some(MainKey::Key(NamedKey::F9 as i32)),
                    10 => Some(MainKey::Key(NamedKey::F10 as i32)),
                    11 => Some(MainKey::Key(NamedKey::F11 as i32)),
                    12 => Some(MainKey::Key(NamedKey::F12 as i32)),
                    _ => return Err("Invalid key"),
                };
                Ok(ProtobufKey {
                    optional_modifier: None,
                    main_key,
                })
            }
            Key::Char(character) => {
                Ok(ProtobufKey {
                    optional_modifier: None,
                    // 97 is the start of the ASCII alphabet
                    main_key: Some(MainKey::Char((character as u8 - 97) as i32)),
                })
            }
            Key::Alt(char_or_arrow) => {
                let main_key = match char_or_arrow {
                    CharOrArrow::Char(character) => MainKey::Char((character as u8 - 97) as i32),
                    CharOrArrow::Direction(Direction::Left) => MainKey::Key(NamedKey::LeftArrow as i32),
                    CharOrArrow::Direction(Direction::Right) => MainKey::Key(NamedKey::RightArrow as i32),
                    CharOrArrow::Direction(Direction::Up) => MainKey::Key(NamedKey::UpArrow as i32),
                    CharOrArrow::Direction(Direction::Down) => MainKey::Key(NamedKey::DownArrow as i32),
                };
                Ok(ProtobufKey {
                    optional_modifier: Some(OptionalModifier::Modifier(KeyModifier::Alt as i32)),
                    main_key: Some(main_key)
                })
            }
            Key::Ctrl(character) => {
                Ok(ProtobufKey {
                    optional_modifier: Some(OptionalModifier::Modifier(KeyModifier::Ctrl as i32)),
                    main_key: Some(MainKey::Char((character as u8 - 97) as i32)),
                })
            }
            Key::BackTab => {
                Ok(ProtobufKey {
                    optional_modifier: None,
                    main_key: Some(MainKey::Key(NamedKey::Tab as i32)),
                })
            }
            Key::Null => {
                Ok(ProtobufKey {
                    optional_modifier: None,
                    main_key: None, // TODO: does this break deserialization?
                })
            }
            Key::Esc => {
                Ok(ProtobufKey {
                    optional_modifier: None,
                    main_key: Some(MainKey::Key(NamedKey::Esc as i32)),
                })
            }
        }
    }
}

impl CharOrArrow {
    pub fn from_main_key(main_key: std::option::Option<MainKey>) -> Result<CharOrArrow, &'static str> {
        match main_key {
            Some(MainKey::Char(encoded_key)) => {
                Ok(CharOrArrow::Char(char_index_to_char(encoded_key)))
            },
            Some(MainKey::Key(key_index)) => {
                match NamedKey::from_i32(key_index) {
                    Some(NamedKey::LeftArrow) => {
                        Ok(CharOrArrow::Direction(Direction::Left))
                    },
                    Some(NamedKey::RightArrow) => {
                        Ok(CharOrArrow::Direction(Direction::Right))
                    },
                    Some(NamedKey::UpArrow) => {
                        Ok(CharOrArrow::Direction(Direction::Up))
                    },
                    Some(NamedKey::DownArrow) => {
                        Ok(CharOrArrow::Direction(Direction::Down))
                    },
                    _ => {
                        Err("Unsupported key")
                    }
                }
            }
            _ => {
                return Err("Unsupported key");
            }
        }
    }
}

fn parse_optional_modifier(m: &ProtobufKey) -> Option<KeyModifier> {
    match m.optional_modifier {
        Some(OptionalModifier::Modifier(modifier)) => KeyModifier::from_i32(modifier),
        _ => None
    }
}


fn char_index_to_char(char_index: i32) -> char {
    // 97 is the start of the alphabet in the ASCII table
    (char_index + 97) as u8 as char
}

fn char_from_main_key(main_key: Option<MainKey>) -> Result<char, &'static str> {
    match main_key {
        Some(MainKey::Char(encoded_key)) => {
            return Ok(char_index_to_char(encoded_key));
        },
        _ => {
            return Err("Unsupported key");
        }
    }
}

fn named_key_to_key(named_key: NamedKey) -> Key {
    match named_key {
        NamedKey::PageDown => Key::PageDown,
        NamedKey::PageUp => Key::PageUp,
        NamedKey::LeftArrow => Key::Left,
        NamedKey::DownArrow => Key::Down,
        NamedKey::UpArrow => Key::Up,
        NamedKey::RightArrow => Key::Right,
        NamedKey::Home => Key::Home,
        NamedKey::End => Key::End,
        NamedKey::Backspace => Key::Backspace,
        NamedKey::Delete => Key::Delete,
        NamedKey::Insert => Key::Insert,
        NamedKey::F1 => Key::F(1),
        NamedKey::F2 => Key::F(2),
        NamedKey::F3 => Key::F(3),
        NamedKey::F4 => Key::F(4),
        NamedKey::F5 => Key::F(5),
        NamedKey::F6 => Key::F(6),
        NamedKey::F7 => Key::F(7),
        NamedKey::F8 => Key::F(8),
        NamedKey::F9 => Key::F(9),
        NamedKey::F10 => Key::F(10),
        NamedKey::F11 => Key::F(11),
        NamedKey::F12 => Key::F(12),
        NamedKey::Tab => Key::BackTab,
        NamedKey::Esc => Key::Esc,
    }
}

